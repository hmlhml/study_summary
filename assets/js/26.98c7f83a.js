(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{381:function(e,n,a){"use strict";a.r(n);var t=a(45),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"_1-mode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-mode"}},[e._v("#")]),e._v(" 1.mode")]),e._v(" "),a("p",[e._v("webpack增加了一个mode配置，只有两种值development | production。对不同的环境他会启用不同的配置。")]),e._v(" "),a("p",[e._v("webpack4中通过内置的mode使用相应模式的内置优化。\n比如设置mode等于'development'，会将 process.env.NODE_ENV 的值设为 development，开发环境下启用optimization.nameModules（原nameModulesPlugin已经弃用）。\n设置mode等于'production'，会将 process.env.NODE_ENV 的值设为 production，而生产环境默认用optimization.noEmitOnErrors`（原noEmitOnErrorsPlugin已弃用）")]),e._v(" "),a("p",[e._v("webpack4中通过内置的mode使用相应模式的内置优化。设置mode等于'development'，会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。\n设置mode等于'production'，会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin.")]),e._v(" "),a("p",[e._v("不同环境下配置如下")]),e._v(" "),a("p",[e._v("1 默认生产环境开起了很多代码优化（minify, splite）\n2 开发时开启注视和验证，并加上了evel devtool\n3 生产环境不支持watching，开发环境优化了打包的速度\n4 生产环境开启模块串联（原ModulecondatenationPlugin）\n5 自动设置process.env.NODE_EVN到不同环境，也就是不使用DefinePlugin了\n6 如果mode设置none，所有默认设置都去掉了。")]),e._v(" "),a("h3",{attrs:{id:"_2-commonschunkplugin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-commonschunkplugin"}},[e._v("#")]),e._v(" 2.CommonsChunkPlugin")]),e._v(" "),a("p",[e._v("CommonChunksPlugin已经从webpack4中移除。可使用optimization.splitChunks进行模块划分（提取公用代码）。")]),e._v(" "),a("p",[e._v("但是需要注意一个问题，默认配置只会对异步请求的模块进行提取拆分，如果要对entry进行拆分，需要设置optimization.splitChunks.chunks = 'all'。")]),e._v(" "),a("p",[e._v("对应之前我们拆分runtime的情况，现在也有一个配置optimization.runtimeChunk，设置为true就会自动拆分runtime文件")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module.exports = {\n  optimization: {\n    runtimeChunk: true,\n    splitChunks: {\n      vendors: {\n        name:  'venders',\n        chunks:  'all',\n        minChunks: 2\n    }\n  }\n}\n")])])]),a("h3",{attrs:{id:"_3-webpack4使用minicssextractplugin取代extracttextwebpackplugin。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-webpack4使用minicssextractplugin取代extracttextwebpackplugin。"}},[e._v("#")]),e._v(" 3.webpack4使用MiniCssExtractPlugin取代ExtractTextWebpackPlugin。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module.exports = {\n  plugins: [\n    new  MiniCssExtractPlugin({\n      filename:  'css/[name].css'\n    }),\n  ],\n}\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test:/\\.vue$/,\n        loader: 'vue-loader',\n      },\n      { test: /\\.css$/,\n         use: [\n                  {\n                    loader: MiniCssExtractPlugin.loader,\n                    options: {\n                      publicPath: '../',\n                      hmr: process.env.NODE_ENV === 'development',\n                    },\n                  },\n                  'css-loader',\n                ],\n        },\n    ]\n  }\n}\n")])])]),a("h3",{attrs:{id:"_4-代码分割。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-代码分割。"}},[e._v("#")]),e._v(" 4.代码分割。")]),e._v(" "),a("p",[e._v("使用动态import，而不是用system.import或者require.ensure")]),e._v(" "),a("h3",{attrs:{id:"_5-vue-loader。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue-loader。"}},[e._v("#")]),e._v(" 5.vue-loader。")]),e._v(" "),a("p",[e._v("使用vue-loader插件为.vue文件中的各部分使用相对应的loader，比如css-loader等")]),e._v(" "),a("h3",{attrs:{id:"_6-uglifyjsplugin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-uglifyjsplugin"}},[e._v("#")]),e._v(" 6.UglifyJsPlugin")]),e._v(" "),a("p",[e._v("现在也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true")]),e._v(" "),a("p",[e._v("optimization.minimizer可以配置你自己的压缩程序")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module.exports = {\n  optimization: {\n    minimizer: [\n      new TerserPlugin({ // 压缩js\n          cache:  true,\n          parallel:  true  //开启多线程\n        }\n      }),\n      new OptimizeCSSAssetsPlugin({ // 压缩css\n        cssProcessorOptions: {\n          safe: true\n        }\n      })\n    ]\n  }\n}\n")])])]),a("p",[e._v("7.移除loaders，必须使用rules（在3版本的时候loaders和rules 是共存的但是到4的时候只允许使用rules）")]),e._v(" "),a("p",[e._v("9.升级happypack插件（happypack可以进行多线程加速打包）")]),e._v(" "),a("p",[e._v("运行在node.js之上的webpack时单线程模型，也就是只能一个一个文件进行处理，不能并行处理，happypack可以将任务分解给多个子进程，最后将结果发给主进程，js是单线程模型，只能通过这种多线程的方式提高性能\nvue-loader 不支持 HappyPack，官方建议用 thread-loader")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const HappyPack = require('happypack');\n\nexports.module = {\n  rules: [\n    {\n      test: /.js$/,\n      use: ['happypack/loader?id=babel'],// 将对.js文件的处理转交给id为babel的HappyPack的实列\n      exclude:/node_modules/\n    }\n  ]\n};\n\nexports.plugins = [\n  new HappyPack({\n    id: 'babel',// 用唯一的标识符id来代表当前的HappyPack 处理一类特定的文件\n    loaders: [ 'babel-loader' ] // 如何处理.js文件，用法和Loader配置是一样的\n  })\n];\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);